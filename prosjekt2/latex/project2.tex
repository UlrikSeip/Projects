\documentclass[a4paper]{article}
% Import some useful packages
\usepackage[margin=0.5in]{geometry} % narrow margins
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath,graphicx,varioref,verbatim,amsfonts,geometry,amssymb,dsfont,blindtext}
%\usepackage{minted}
\usepackage{amsmath}
\usepackage{xcolor}
\hypersetup{colorlinks=true}
\definecolor{LightGray}{gray}{0.95}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}
\definecolor{LightGray}{gray}{0.95}
\lstset{frame=tb,
	language=Python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	backgroundcolor=\color{mygray}
	%breaklines=true,
	%breakatwhitespace=true,
	%tabsize=3
}
\title{Project 2 in FYS3150}
\author{Bendik Steinsvåg Dalen, Ulrik Seip}
%\renewcommand\thesection.\alph{section}
%\renewcommand\thesection{\Alph{section}}
\renewcommand\thesubsection{\thesection.\alph{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\roman{subsubsection}}
\begin{document}
\maketitle

\section{ABSTRACT}
In this project we have implemented Jacobian algorithm, to find eigenvectors, and their corresponding eigenvalues in tridiagonal matrices. We then used this to model a harmonic oscillator problem in three dimensions, with one and two electrons. This turned out to be a computationally heavy, but relatively accurate method.

\section{INTRODUCTION}
Finding eigenvectors analytically is complicated, and can be tedious, and this is why it is much more convenient to do so numerically. A common way of doing this is by the application of the Jacobian method. Essentially we rotate one matrix element at a time, always taking the one with the highest absolute value, until all but the diagonal elements are essentially zero. All transformations are also applied to an identity matrix that then turns into our eigenvectors. 

\section{METHOD}

\subsection{Implementing the Jacobian algorithm}
The implementation follows a standard recipe:
We start with the relation
\begin{equation*}\cot 2\theta=\tau = \frac{a_{ll}-a_{kk}}{2a_{kl}}.
\end{equation*}
This can be used to find the angle $\theta$ that makes the  non-diagonal matrix elements of the transformed matrix 
$a_{kl} = 0$. The quadratic equation is obtained using $\cot 2\theta=1/2(\cot\theta-\tan\theta)$.

\begin{align}
t^2+2\tau t-1=0
\end{align}
Which gives us
\begin{align}
t = -\tau \pm \sqrt{1+\tau^2}
\end{align}
$c$ and $s$ are then obtained by
\begin{align}
c = \frac{1}{\sqrt{1+t^2}}
\end{align}
and
\begin{align}
s=tc
\end{align}  

We then use the rotational factors $c$ and $s$ to rotate every other element in the matrix according to their position, giving us a new diagonal, that is slightly closer to the eigenvalues, and new matrix elements elsewhere, slightly closer to 0. The same is done for a matrix that tarts out as an identity matrix, with the purpose of transforming it into the original matrix' eigenvectors. See the documentation in section \ref{rotator.jl} for further explanation.

\subsection{Testing the code}
For testing the algorithm we have implemented two tests. One for checking if the largest element in the matrix is correctly located, and one for testing if the resulting eigenvalues are correct. The first one is more useful for development purposes, whilst the second one is essential for validating that our implementation works correctly.

\subsection{Quantum dots in three dimensions, one electron}
Now that we had a general algorithm we used it to model a electron that moves in a three-dimensional harmonic oscillator potential. In other words, we looked for the solution of the radial part of Schroedinger’s
equation for one electron, which reads
\begin{align}
- \frac{\hbar^2}{2m} \left( \frac{1}{r^2} \frac{d}{dr} r^2 \frac{d}{dr} - \frac{l(l+1)}{r^2}\right) R(r) + V(r) R(r) = ER(r).
\end{align}
This problem also has analytical solutions, so we can test how accurate our algorithm is.

(Some math-stuff).

The Schroedinger’s equation then becomes
\begin{align}
-\frac{d^2}{d\rho^2} u(\rho) + \rho^2 u(\rho) = \lambda y(\rho). \label{simpel SE}
\end{align}
Since we are working in radial coordinates we have $\rho \in [0,\infty)$. Since we can't represent infinity on a computer we have to find an approximation, which we will come back to later. For now we define $\rho_{min}=0$ and $\rho_{max}$ to represent the  minimum and maximum values of $\rho$. 

Function \ref{simpel SE} is an differential equation that can be modeled similarly to (ting). If we have $n$ mesh points we get a step length
\begin{align}
h = \frac{\rho_{max} - \rho_{min}}{n}.
\end{align}
The value of $\rho$ at a point $i$ is then 
\begin{align}
\rho_i= \rho_0 + ih \hspace{1cm} i=1,2,\dots , N.
\end{align}

\subsection{Quantum dots in three dimensions, two electrons}


\section{RESULTS}
\subsection{The implementation}
We see a fairly linear correlation between the number of matrix elements $n^2$ and the required amount similarity transformations. The computation time for each matrix was also proportional to $n^2$ In figure \ref{computation time plot} the tolerance for deviation from 0 in the non diagonal elements was $1e-4$. We found this to be the best balance between accuracy and efficiency. 
\begin{figure}[h!]
	\centering 
	%Scale angir størrelsen på bildet. Bildefilen må ligge i %samme mappe som tex-filen. 
	\includegraphics[scale=0.7]{requiredRotations.pdf}
	\caption{A plot of the required number of rotations as a function of n: $rotations/n^2$, and the time used for calculating the eigenvalues of a $n\cdot n$ matrix.}
	%Label gjør det enkelt å referere til ulike bilder.
	\label{computation time plot}
\end{figure}

\section{CONCLUSIONS}
With an accuracy of more digits than our editor cared to print out the Jacobi method, with a tolerance for non diagonal values of up to $1e-4$, seems to be an efficient and precise algorithm for computing eigenvectors and eigenvalues. The computation time is proportional to the number of matrix elements, and so the realistic limit for matrix size should be around $10^4 \cdot 10^4$. With $300 \cdot 300$ taking 12 seconds, $10^4 \cdot 10^4$ should take about
\begin{align}
\frac{(10^4)^2}{300^2}\cdot 12s\approx 4h
\end{align}
on a normal laptop. On a supercomputer this would of course be different, and i presume our implementation could have been further vectorised for greater efficiency.
\section{APENDICES}
\subsection{Integration loop from rotator.jl}\label{rotator.jl}
\lstinputlisting[language = python, firstline = 35, lastline = 98]{../rotator.jl}

\section{REFERENCES}
\begin{thebibliography}{9}
	\bibitem{lecture notes}
	Computational Physics, Lecture Notes Fall 2015, Morten Hjort-Jensen p.215-220
\end{thebibliography}




%\begin{figure}[h!]
%	\centering 
%	%Scale angir størrelsen på bildet. Bildefilen må ligge i samme mappe som tex-filen. 
%	\includegraphics[scale=0.7]{opp2_7.pdf}
%	\caption{A plot of the entropy}
%	%Label gjør det enkelt å referere til ulike bilder.
%	\label{2.7}
%\end{figure}






















\end{document}