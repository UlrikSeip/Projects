\documentclass[a4paper]{article}
% Import some useful packages
\usepackage[margin=0.5in]{geometry} % narrow margins
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath,graphicx,varioref,verbatim,amsfonts,geometry,amssymb,dsfont,blindtext}
%\usepackage{minted}
\usepackage{amsmath}
\usepackage{xcolor}
\hypersetup{colorlinks=true}
\definecolor{LightGray}{gray}{0.95}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}
\definecolor{LightGray}{gray}{0.95}
\lstset{frame=tb,
	language=Python,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	backgroundcolor=\color{mygray}
	%breaklines=true,
	%breakatwhitespace=true,
	%tabsize=3
}
\title{Project 2 in FYS3150}
\author{Bendik Steinsvåg Dalen, Ulrik Seip}
%\renewcommand\thesection.\alph{section}
%\renewcommand\thesection{\Alph{section}}
\renewcommand\thesubsection{\thesection.\alph{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\roman{subsubsection}}
\begin{document}
\maketitle

\section{ABSTRACT}

In this project we have implemented Jacobian algorithm, to find eigenvectors, and their corresponding eigenvalues in tridiagonal matrices. We then used this to model a harmonic oscillator problem in three dimensions, with one and two electrons. This turned out to be a computationally heavy, but relatively accurate method.

\section{INTRODUCTION}

Finding eigenvectors analytically is complicated, and can be tedious, and this is why it is much more convenient to do so numerically. A common way of doing this is by the application of the Jacobian method. Essentially we rotate one matrix element at a time, always taking the one with the highest absolute value, until all but the diagonal elements are essentially zero. All transformations are also applied to an identity matrix that then turns into our eigenvectors. 

\section{METHOD}

\subsection{Implementing the Jacobian algorithm}
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

=======
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
=======
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
=======
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
The implementation follows a standard recipe:
We start with the relation
\begin{equation*}\cot 2\theta=\tau = \frac{a_{ll}-a_{kk}}{2a_{kl}}.
\end{equation*}
This can be used to find the angle $\theta$ that makes the  non-diagonal matrix elements of the transformed matrix 
$a_{kl} = 0$. The quadratic equation is obtained using $\cot 2\theta=1/2(\cot\theta-\tan\theta)$.

\begin{align}
t^2+2\tau t-1=0
\end{align}
Which gives us
\begin{align}
t = -\tau \pm \sqrt{1+\tau^2}
\end{align}
$c$ and $s$ are then obtained by
\begin{align}
c = \frac{1}{\sqrt{1+t^2}}
\end{align}
and
\begin{align}
s=tc
\end{align}  

We then use the rotational factors $c$ and $s$ to rotate every other element in the matrix according to their position, giving us a new diagonal, that is slightly closer to the eigenvalues, and new matrix elements elsewhere, slightly closer to 0. The same is done for a matrix that tarts out as an identity matrix, with the purpose of transforming it into the original matrix' eigenvectors. See the documentation in section \ref{rotator.jl} for further explanation.

\subsection{Testing the code}

For testing the algorithm we have implemented two tests. One for checking if the largest element in the matrix is correctly located, and one for testing if the resulting eigenvalues are correct. The first one is more useful for development purposes, whilst the second one is essential for validating that our implementation works correctly.

\subsection{Quantum dots in three dimensions, one electron}

Now that we had a general algorithm we used it to model a electron that moves in a three-dimensional harmonic oscillator potential. In other words, we looked for the solution of the radial part of Schroedinger’s
equation for one electron, which reads
\begin{align}
- \frac{\hbar^2}{2m} \left( \frac{1}{r^2} \frac{d}{dr} r^2 \frac{d}{dr} - \frac{l(l+1)}{r^2}\right) R(r) + V(r) R(r) = ER(r).
\end{align}
This problem also has analytical solutions, so we can test how accurate our algorithm is.

We decided to limit our experiment to the ground state of $l=0$. After introducing the constant $\alpha = \left(\frac{\hbar^2}{mk}\right)^{1/4}$, and the variables $\lambda = \frac{2m\alpha^2}{\hbar^2}E$ and $\rho = \frac{r}{\alpha}$, the Schroedinger’s equation becomes
\begin{align}
-\frac{d^2}{d\rho^2} u(\rho) + \rho^2 u(\rho) = \lambda u(\rho). \label{simpel SE}
\end{align}
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
See section \ref{opp d math} for futher details. 
=======
Since we are working in radial coordinates we have $\rho \in [0,\infty)$. Since we can't represent infinity on a computer we have to find an approximation, which we will come back to later. For now we define $\rho_{min}=0$ and $\rho_{max}$ to represent the  minimum and maximum values of $\rho$. 
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
=======
Since we are working in radial coordinates we have $\rho \in [0,\infty)$. Since we can't represent infinity on a computer we have to find an approximation, which we will come back to later. For now we define $\rho_{min}=0$ and $\rho_{max}$ to represent the  minimum and maximum values of $\rho$. 
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f

Since we are working in radial coordinates we have $\rho \in [0,\infty)$. Since we can't represent infinity on a computer we have to find an aproximation, which we will come back to later. For now we define $\rho_{min}=10^{-6}$ and $\rho_{max}$ to represent the  minimum and maximum values of $\rho$. We used $10^{-6}$ instead of $0$ to avoid any potential divisions by zero.

Function \ref{simpel SE} is an differential equation that can be modeled similarly to earlier. If we have $N$ mesh points we get a step length
=======
=======
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
Since we are working in radial coordinates we have $\rho \in [0,\infty)$. Since we can't represent infinity on a computer we have to find an approximation, which we will come back to later. For now we define $\rho_{min}=0$ and $\rho_{max}$ to represent the  minimum and maximum values of $\rho$. 

Function \ref{simpel SE} is an differential equation that can be modeled similarly to (ting). If we have $n$ mesh points we get a step length
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
\begin{align}
h = \frac{\rho_{max} - \rho_{min}}{N}.
\end{align}
The value of $\rho$ at a point $i$ is then 
\begin{align}
\rho_i= \rho_0 + ih \hspace{1cm} i=1,2,\dots , N.
\end{align}
We can rewrite the Schroedinger equation for a value $\rho_i$ as
\begin{align}
-\frac{u_{i+1} -2u_i +u_{i-1}}{h^2}+\rho_i^2u_i = \lambda u_i).
\end{align}
We then introduced
\begin{align}
   d_i=\frac{2}{h^2}+\rho_{i}^2,
\end{align}
and
\begin{align}
e_{i} = -\frac{1}{\hbar^2},
\end{align}
which gives us
\begin{align}
d_iu_i+e_{i-1}u_{i-1}+e_{i+1}u_{i+1}  = \lambda u_i.
\end{align}
We then wrote the latter equation as a matrix eigenvalue problem
\begin{equation}
\begin{bmatrix}d_0 & e_0 & 0   & 0    & \dots  &0     & 0 \\
e_1 & d_1 & e_1 & 0    & \dots  &0     &0 \\
0   & e_2 & d_2 & e_2  &0       &\dots & 0\\
\dots  & \dots & \dots & \dots  &\dots      &\dots & \dots\\
0   & \dots & \dots & \dots  &\dots  e_{N-1}     &d_{N-1} & e_{N-1}\\
0   & \dots & \dots & \dots  &\dots       &e_{N} & d_{N}
\end{bmatrix}  \begin{bmatrix} u_{0} \\
u_{1} \\
\dots\\ \dots\\ \dots\\
u_{N}
\end{bmatrix}=\lambda \begin{bmatrix} u_{0} \\
u_{1} \\
\dots\\ \dots\\ \dots\\
u_{N}
\end{bmatrix}.  
\label{eq:sematrix}
\end{equation}
This is effectively the same problem as earlier, only that we have to add $\rho_{i}^2$ to the diagonal elements. 

To solve the problem we implemented the matrix in Julia, and run it through the algorithm in section \ref{rotator.jl}, with a tolerance of $10^{-4}$. The implemtation of the matrix can be seen in section \ref{opp_d matrix}. What we then did was test different approximations for $\rho_{max}$ and $N$ to find some values that are accurate and don't require a extemly large $N$. Our goal was to reproduce the analytical results with four leading digits after the decimal point.

\subsection{Quantum dots in three dimensions, two electrons}


\section{RESULTS}
\subsection{The implementation}
We see a fairly linear correlation between the number of matrix elements $n^2$ and the required amount similarity transformations. The computation time for each matrix was also proportional to $n^2$ In figure \ref{computation time plot} the tolerance for deviation from 0 in the non diagonal elements was $1e-4$. We found this to be the best balance between accuracy and efficiency. 
\begin{figure}[h!]
	\centering 
	%Scale angir størrelsen på bildet. Bildefilen må ligge i %samme mappe som tex-filen. 
<<<<<<< HEAD
<<<<<<< HEAD
	\includegraphics[scale=0.7]{../requiredRotations.pdf}
=======
	\includegraphics[scale=0.7]{requiredRotations.pdf}
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
=======
	\includegraphics[scale=0.7]{requiredRotations.pdf}
>>>>>>> 9424cd94b453e522fd2ee81f1c10716390c79e9f
	\caption{A plot of the required number of rotations as a function of n: $rotations/n^2$, and the time used for calculating the eigenvalues of a $n\cdot n$ matrix.}
	%Label gjør det enkelt å referere til ulike bilder.
	\label{computation time plot}
\end{figure}

\section{CONCLUSIONS}
With an accuracy of more digits than our editor cared to print out the Jacobi method, with a tolerance for non diagonal values of up to $1e-4$, seems to be an efficient and precise algorithm for computing eigenvectors and eigenvalues. The computation time is proportional to the number of matrix elements, and so the realistic limit for matrix size should be around $10^4 \cdot 10^4$. With $300 \cdot 300$ taking 12 seconds, $10^4 \cdot 10^4$ should take about
\begin{align}
\frac{(10^4)^2}{300^2}\cdot 12s\approx 4h
\end{align}
on a normal laptop. On a supercomputer this would of course be different, and i presume our implementation could have been further vectorised for greater efficiency.
\section{APENDICES}
\subsection{Integration loop from rotator.jl}\label{rotator.jl}
\lstinputlisting[language = python, firstline = 35, lastline = 98]{../rotator.jl}

\subsection{Math for Quantum dots in three dimensions, one electron}\label{opp d math}
We begin with 
\begin{align}
- \frac{\hbar^2}{2m} \left( \frac{1}{r^2} \frac{d}{dr} r^2 \frac{d}{dr} - \frac{l(l+1)}{r^2}\right) R(r) + V(r) R(r) = ER(r).
\end{align}
Firstly we had that $l=0$. We then substitue $R(r) = u(r)/r$


\subsection{Implementing a matrix in Julia}\label{opp_d matrix}
\lstinputlisting[language = python, firstline = 5, lastline = 27]{../opp_d.jl}

\section{REFERENCES}
\begin{thebibliography}{9}
	\bibitem{lecture notes}
	Computational Physics, Lecture Notes Fall 2015, Morten Hjort-Jensen p.215-220
\end{thebibliography}




%\begin{figure}[h!]
%	\centering 
%	%Scale angir størrelsen på bildet. Bildefilen må ligge i samme mappe som tex-filen. 
%	\includegraphics[scale=0.7]{opp2_7.pdf}
%	\caption{A plot of the entropy}
%	%Label gjør det enkelt å referere til ulike bilder.
%	\label{2.7}
%\end{figure}






















\end{document}